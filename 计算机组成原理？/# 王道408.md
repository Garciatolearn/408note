# 王道408

## 1.0 第一章

前言:采取()的内容皆为促进理解而写下的东西

### 1.1 data数据 电信号与金手指
硬件例如cpu 硬盘 内存条的那些金手指()是用来传递数据
所有数据都是由二进制组成的
计算机硬件如何区分0/1这两种数据信号?
答案是靠高低电平(电压之)来表示
其中硬件这种金属针脚(金手指)就是用来接收识别高低电平(电信号)的!

![image-20230528173307549](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230528173307549.png)
太酷啦

他们之间交换数据通过主板的印刷电路板上的电路来传输交换

---



### 1.1概述
计算机系统=软件+硬件
软件分为两种:** 系统软件**or** 应用软件**
系统软件:用来管理整个计算机的软件:操作系统,DBMS(数据库操作系统),网络软件(处理tcp,udp协议的软件模块),程序库(编程时使用的库函数)等
应用软件:qq,网易云:那种按任务编制成的程序
世界上第一台计算机的逻辑元件(电子管)来处理电信号

![image-20230528180037253](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230528180037253.png) 

cpu的机器字长:计算机一次整数运行所能处理的二进制位数

主要记住每一代计算机逻辑元件的更替:

第一代是电子管,功耗确实高体积确实大性能确实拉

第二代是晶体管,量大东西小,但是人工焊接易翻车

第三代是小型集成电路,有工艺的,不易犯车,性能吊(其实就是把晶体管,电容这些元器件高密度集成在电路板上)

### 1.2计算机硬件的基本组成

在第一代计算机中因为都要手接线来来控制计算，冯诺依曼提出了**存储程序的概念**：" 将指令以二进制代码的形式事先输入计算机的主存储器当中，让计算机按着该程序的规定顺序执行其他的命令；"

![image-20230529091824635](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230529091824635.png)

输入设备：能将信息转化成机器能识别的形式，也即是而二进制数

存储器：顾名思义，存储数据和程序的

运算器：主要做逻辑运算和算术运算

 输出设备：将数据转化为人类熟悉的形式，也就是将二进制通过特别的编码规则来呈现出文字，图片等

控制器：协调计算机各部件的操作👇，还能解析存储器里面的程序指令；（指挥程序有条不紊运行的）

> 控制器的解析：例如 在进行加法操作时，控制器会往存储器读取并解析加法指令，然后指挥计算器执行加法运算：

在计算机系统当中：软件和硬件在逻辑上是等效的,也就是说同一个功能可以用两种方式实现



> 举个例子:如果我们要实现除法功能,如果是软件实现的话 成本很低 但是运行效率也会很低,反之;

> 如果是硬件去实现的话可以在运算器上面去设计一个专门的硬件电路来实现;

> 如果是软件的话相当于是用多个加法运算来实现

 <font size="5">总结</font>

1. 冯诺依曼结构分为五大部件组成
2. **指令和数据以同等地位存储在存储器当中**,可以按着地址寻访(初步理解为C语言指针所指的地址)
3. 指令和数据都是以二进制表示的
4. **指令是由操作码和地址码来组成**→前者是决定控制器解析之后什么组件干什么活,后者是👆
5. 存储程序(详情康这里)
6. 以运算器为中心!!!!以运算器为中心!!!!以运算器为中心!!!!

运算器相当于是中转站,将数据转储到存储器里面

其中的输入和输出设备可以被叫做io设备

---



但是以运算器为中心其实有一个问题,就本来运算器是用来处理数据,但所有数据的运转都需要他来完成.

这样肯定会消耗运算器性能导致效率下降

---



为了解决这种问题,**现代计算机的结构**应运而生!

现代计算机以<font size='6'>存储器</font>为中心

![image-20230529153115453](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230529153115453.png)

就是把冯诺依曼的存储器和运算器换个位置,好处有两个,优化了运算器的工作效率,存取数据时可以节省一道运算器的工序;

由于运算器和控制器逻辑紧密,在这一代的cpu(大规模集成电路当中)把这两者集成,简化之后 belike:

![image-20230529155429395](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230529155429395.png)

为啥辅存属于io类???

首先主存在电脑里就是我们熟知的内存,辅存就是机械硬盘.

我的理解是在计算机里处理计算内容都是通过内存和cpu的交互,辅存是数据库主要是将数据提供给主存使用的,和io设备干的活差不多 

![image-20230529164712513](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230529164712513.png)

### 1.2.2 各个硬件的工作原理

在这一章节我们将探讨主机当中硬件之间是如何协调工作的.上一章只不过是大致讲了一下关于硬件间的大致内容

前置知识:寄存器也是放数据的()

首先是主存储器的基本组成:

主存储器是由主存储体和MAR,MDR

首先是主存储体:可以存放二进制 0 1 数据 并且是按着地址存储(相当于数据仓库)

MAR(Memory Adress Register/存储**地址寄存器**):(类似于请求清单)

MDR(Memory Data Register/存储**数据寄存器**):(相当于一个缓存区)

为了更好理解,这是cpu到主存储器中请求获取数据的全过程:

> 首先cpu通过控制总线通知主存储器这次是读取数据的操作

> 然后将想要获取的数据地址写入MAR当中,

> 主存储器通过读取MAR中的地址在找到主存储体里存放的数据,

> 之后把找到到的数据写入到MDR里面让cpu获取数据.

写入数据的过程也大差不差,请自行理解之后脑补一下~~

> 写入的话,就是cpu先把想写的内容写入到MDR当中,然后再把要写入的地址写到MAR里

现在我们focus到主存储体当中：

![image-20230531093123141](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230531093123141.png)

一般存储字长都是8bit或者16bit or 8bit的整数倍

存储单元等于线路加上存储元

**MAR的位数反映了存储体的存储单元的个数**

**MDR的位数等于存储字长**

![image-20230531094532665](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230531094532665.png)

这一个字是由计算机硬件来决定的，非固定的人为规定

接下来到 <font size='6'>运算器</font> 的环节

![image-20230531095227573](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230531095227573.png)

两眼一黑,不知道从哪看起,我们先逐步拆解

运算器由三个寄存器加上一个核心部件组成

ACC (accumulator) 累加器:其实也是一个寄存器,用以存储操作数或者运算结果

MQ (multiple-Quotient Register) 乘商寄存器:顾名思义,同上

Arithmetic and Logic Unit 算术逻辑单元:核心部件,由**复杂**的电路来实现运算功能

x:不知道是什么缩写,通用的操作数寄存器,一般拿来存操作数,实际上在硬件当中存在多个

在上面的表格中我们可以发现规律:

> ps:下面的只适用于加减除
>
> 通用寄存器是用来存储操作的数 be like:    加数
>
> 累加器是存储被操做的数以及结果 be like:    被加数,和(special情况:被除数,余数)
>
> 乘商寄存器 比较特别大体上是存储结果?:存商
>
> 乘法比较特别:
>
> acc存乘积的高位,mqr存的是乘积高位和乘数,x反而存储被乘数

然后到了重量级___控制器

控制器由三个部件组成:

CU(control Unit) 控制单元:最核心的部件,内部是由复杂电路集成,可以分析指令,发出控制信号

IR(instructions Register)指令寄存器:存储当前执行的指令

PC(program Counter) 程序计数器:存储下一条指令的地址,可以自动加1

运行一段代码本质上就是运行一条指令

![image-20230531112952728](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230531112952728.png)

通俗易懂

我们将代码运行,计算机会先将代码编译转化为机器语言然后按顺序装载到内存里面:

> 很好的体现了1.2总结里面的指令和数据的共同点与不同点
>
> cpu会自动将指令的存储字拆解两种码

![image-20230531113059078](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230531113059078.png)

解读流程的前置小知识: pc通过地址总线传递指令地址(ps:看情况,并不是固定为主存地址或者地址码)

控制器通过控制总线来对硬件进行控制

MDR通过数据总线将数据进行传输

![image-20230531115121284](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230531115121284.png)

在取值令的行为结束之后PC自动加1

![image-20230601111242597](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230601111242597.png)

在这里体现的是乘积的高低位什么时候能要使用MQ

![image-20230601112618665](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230601112618665.png)

![image-20230601113128390](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230601113128390.png)

ps：现代计算机会把MAR和MDR集成在cpu当中

### 1.2.3 计算机的层次结构

![image-20230601115330319](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230601115330319.png)

老样子，从底层开始发散疏通内容：

先从最底层开始入手，首先是传统机器M1 只识别并执行二进制的指令

 比如之前的加法指令为例子： 分析完知道这条指令是干啥的之后 通过微程序机器 M0 将其指令分解成一个个小小的微指令来完成过加法指令。

M1：执行二进制机器指令

M0： 通过**硬件**直接执行微指令

很显然，

如果你能做到在主存储器当中写入二进制代码来编写程序，太酷啦。但这对于程序员来说太难了于是就另辟蹊径

创造了 虚拟机器 M3 （汇编语言机器）通过助记符 来进行更便利易理解的编程，之所以叫做虚拟是因为  计算机只是看起来能直接运行汇编语言写的代码，但实际上计算机并不能直接执行汇编语言

编程中汇编的你，再便利也是假的（，计算机会通过汇编程序将汇编语言一一对应翻译成机器语言程序来执行。

可还是不够方便，于是出现了更牛逼的M4 （高级语言机器）将高级语言程序（c java go rust之类的）通过编译程序翻译成汇编语言程序

当然在我们写程序时也会调用操作系统的api 于是就在汇编程序同样也需要请求操作系统的服务，这就是虚拟机器M2（操作系统机器） 提供广义上的指令给上面两层机器使用

上面就把层次梳理完毕

![image-20230601122701541](C:\Users\Garcia\AppData\Roaming\Typora\typora-user-images\image-20230601122701541.png)



